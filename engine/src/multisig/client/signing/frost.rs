//! The types and operations as discussed in <https://eprint.iacr.org/2020/852.pdf>.
//! Comments in this file reference sections from this document.
//! Note that unlike the protocol described in the document, we don't have a
//! centralised signature aggregator and don't have a preprocessing stage.

use std::{
    collections::{BTreeMap, BTreeSet},
    convert::TryInto,
    fmt::Display,
};

use cf_traits::AuthorityCount;
use serde::{Deserialize, Serialize};

use zeroize::Zeroize;

use crate::multisig::{
    client::common::BroadcastVerificationMessage,
    crypto::{CryptoScheme, ECPoint, ECScalar, KeyShare, Rng},
};

use sha2::{Digest, Sha256};

/// A pair of secret single-use nonces (and their
/// corresponding public commitments). Correspond to (d,e)
/// generated during the preprocessing stage in Section 5.3 (page 13)
// TODO: Not sure if it is a good idea to to make
// the secret values clonable
#[derive(Debug, Clone, Zeroize)]
pub struct SecretNoncePair<P: ECPoint> {
    pub d: P::Scalar,
    pub d_pub: P,
    pub e: P::Scalar,
    pub e_pub: P,
}

impl<P: ECPoint> SecretNoncePair<P> {
    /// Generate a random pair of nonces (in a Box,
    /// to avoid them being copied on move)
    pub fn sample_random(rng: &mut Rng) -> Box<Self> {
        let d = P::Scalar::random(rng);
        let e = P::Scalar::random(rng);

        let d_pub = P::from_scalar(&d);
        let e_pub = P::from_scalar(&e);

        Box::new(SecretNoncePair { d, d_pub, e, e_pub })
    }
}

/// Public components of the single-use nonces generated by
/// a single party at signer index `index`.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]

pub struct SigningCommitment<P: ECPoint> {
    #[serde(bound = "")]
    pub d: P,
    #[serde(bound = "")]
    pub e: P,
}

pub type Comm1<P> = SigningCommitment<P>;

pub type VerifyComm2<P> = BroadcastVerificationMessage<Comm1<P>>;
pub type VerifyLocalSig4<P> = BroadcastVerificationMessage<LocalSig3<P>>;

/// Signature (the "response" part) shard generated by a single party
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct LocalSig3<P: ECPoint> {
    pub response: P::Scalar,
}

/// Data exchanged between parties during various stages
/// of the FROST signing protocol
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum SigningData<P: ECPoint> {
    #[serde(bound = "")]
    CommStage1(Comm1<P>),
    #[serde(bound = "")]
    BroadcastVerificationStage2(VerifyComm2<P>),
    #[serde(bound = "")]
    LocalSigStage3(LocalSig3<P>),
    #[serde(bound = "")]
    VerifyLocalSigsStage4(VerifyLocalSig4<P>),
}

derive_impls_for_enum_variants!(impl<P: ECPoint> for Comm1<P>, SigningData::CommStage1, SigningData<P>);
derive_impls_for_enum_variants!(impl<P: ECPoint> for VerifyComm2<P>, SigningData::BroadcastVerificationStage2, SigningData<P>);
derive_impls_for_enum_variants!(impl<P: ECPoint> for LocalSig3<P>, SigningData::LocalSigStage3, SigningData<P>);
derive_impls_for_enum_variants!(impl<P: ECPoint> for VerifyLocalSig4<P>, SigningData::VerifyLocalSigsStage4, SigningData<P>);

derive_display_as_type_name!(Comm1<P: ECPoint>);
derive_display_as_type_name!(VerifyComm2<P: ECPoint>);
derive_display_as_type_name!(LocalSig3<P: ECPoint>);
derive_display_as_type_name!(VerifyLocalSig4<P: ECPoint>);

impl<P: ECPoint> Display for SigningData<P> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let inner = match self {
            SigningData::CommStage1(x) => x.to_string(),
            SigningData::BroadcastVerificationStage2(x) => x.to_string(),
            SigningData::LocalSigStage3(x) => x.to_string(),
            SigningData::VerifyLocalSigsStage4(x) => x.to_string(),
        };
        write!(f, "SigningData({})", inner)
    }
}

impl<P: ECPoint> SigningData<P> {
    /// Check that the number of elements and indexes in the data is correct
    pub fn check_data_size(&self, num_of_parties: Option<AuthorityCount>) -> bool {
        if let Some(num_of_parties) = num_of_parties {
            match self {
                // For messages that don't contain a collection (eg. CommStage1), we don't need to check the size.
                SigningData::CommStage1(_) => true,
                SigningData::BroadcastVerificationStage2(message) => {
                    message.data.len() == num_of_parties as usize
                }
                SigningData::LocalSigStage3(_) => true,
                SigningData::VerifyLocalSigsStage4(message) => {
                    message.data.len() == num_of_parties as usize
                }
            }
        } else {
            assert!(
                matches!(self, SigningData::CommStage1(_)),
                "We should know the number of participants for any non-initial stage data"
            );
            true
        }
    }
}

/// Combine individual commitments into group (schnorr) commitment.
/// See "Signing Protocol" in Section 5.2 (page 14).
fn gen_group_commitment<P: ECPoint>(
    signing_commitments: &BTreeMap<AuthorityCount, SigningCommitment<P>>,
    bindings: &BTreeMap<AuthorityCount, P::Scalar>,
) -> P {
    signing_commitments
        .iter()
        .map(|(idx, comm)| {
            let rho_i = bindings[idx].clone();
            comm.d + comm.e * rho_i
        })
        .sum()
}

/// Generate a lagrange coefficient for party `signer_index`
/// according to Section 4 (page 9)
pub fn get_lagrange_coeff<P: ECPoint>(
    signer_index: AuthorityCount,
    all_signer_indices: &BTreeSet<AuthorityCount>,
) -> anyhow::Result<P::Scalar> {
    use anyhow::Context;

    let mut num = P::Scalar::from_usize(1);
    let mut den = P::Scalar::from_usize(1);

    for j in all_signer_indices {
        if *j == signer_index {
            continue;
        }
        let j: usize = (*j).try_into().expect("too many signers");
        let j = P::Scalar::from_usize(j);
        let signer_index = P::Scalar::from_usize(signer_index as usize);
        num = num * j.clone();
        den = den * (j - signer_index);
    }

    let lagrange_coeff = num
        * den
            .invert()
            .context("Can't invert a zero scalar. Processing duplicate shares?")?;

    Ok(lagrange_coeff)
}

/// Generate a "binding value" for party `index`. See "Signing Protocol" in Section 5.2 (page 14)
fn gen_rho_i<P: ECPoint>(
    index: AuthorityCount,
    msg: &[u8],
    signing_commitments: &BTreeMap<AuthorityCount, SigningCommitment<P>>,
    all_idxs: &BTreeSet<AuthorityCount>,
) -> P::Scalar {
    let mut hasher = Sha256::new();
    hasher.update(b"I");
    hasher.update(index.to_be_bytes());
    hasher.update(msg);

    // This needs to be processed in order!

    for idx in all_idxs {
        let com = &signing_commitments[idx];
        hasher.update(idx.to_be_bytes());
        hasher.update(com.d.as_bytes());
        hasher.update(com.e.as_bytes());
    }

    let result = hasher.finalize();

    let x: [u8; 32] = result.as_slice().try_into().expect("Invalid hash size");

    P::Scalar::from_bytes(&x)
}

type SigningResponse<P> = LocalSig3<P>;

/// Generate binding values for each party given their previously broadcast commitments
fn generate_bindings<P: ECPoint>(
    msg: &[u8],
    commitments: &BTreeMap<AuthorityCount, SigningCommitment<P>>,
    all_idxs: &BTreeSet<AuthorityCount>,
) -> BTreeMap<AuthorityCount, P::Scalar> {
    all_idxs
        .iter()
        .map(|idx| (*idx, gen_rho_i(*idx, msg, commitments, all_idxs)))
        .collect()
}

/// Generate local signature/response (shard). See step 5 in Figure 3 (page 15).
pub fn generate_local_sig<C: CryptoScheme>(
    msg_hash: &[u8; 32],
    key: &KeyShare<C::Point>,
    nonces: &SecretNoncePair<C::Point>,
    commitments: &BTreeMap<AuthorityCount, SigningCommitment<C::Point>>,
    own_idx: AuthorityCount,
    all_idxs: &BTreeSet<AuthorityCount>,
) -> SigningResponse<C::Point> {
    let bindings = generate_bindings(msg_hash, commitments, all_idxs);

    // This is `R` in a Schnorr signature
    let group_commitment = gen_group_commitment(commitments, &bindings);

    let SecretNoncePair { d, e, .. } = nonces;

    let lambda_i = get_lagrange_coeff::<C::Point>(own_idx, all_idxs).expect("lagrange coeff");

    let rho_i = bindings[&own_idx].clone();

    let nonce_share = rho_i * e + d;

    let key_share = lambda_i * &key.x_i;

    let response =
        generate_schnorr_response::<C>(&key_share, key.y, group_commitment, nonce_share, msg_hash);

    SigningResponse { response }
}

pub fn generate_schnorr_response<C: CryptoScheme>(
    private_key: &<C::Point as ECPoint>::Scalar,
    pubkey: C::Point,
    nonce_commitment: C::Point,
    nonce: <C::Point as ECPoint>::Scalar,
    msg_hash: &[u8; 32],
) -> <C::Point as ECPoint>::Scalar {
    let challenge = C::build_challenge(pubkey, nonce_commitment, msg_hash);

    C::build_response(nonce, private_key, challenge)
}

/// Check the validity of a signature response share.
/// (See step 7.b in Figure 3, page 15.)
/// TODO: we will likely need a separate verification
/// function for each blockchain
fn is_party_response_valid<Point: ECPoint>(
    y_i: &Point,
    lambda_i: &Point::Scalar,
    commitment: &Point,
    challenge: &Point::Scalar,
    signature_response: &Point::Scalar,
) -> bool {
    Point::from_scalar(signature_response) == *commitment - (*y_i) * challenge * lambda_i
}

/// Combine local signatures received from all parties into the final
/// (aggregate) signature given that no party misbehaved. Otherwise
/// return the misbehaving parties.
pub fn aggregate_signature<C: CryptoScheme>(
    msg_hash: &[u8; 32],
    signer_idxs: &BTreeSet<AuthorityCount>,
    agg_pubkey: C::Point,
    pubkeys: &BTreeMap<AuthorityCount, C::Point>,
    commitments: &BTreeMap<AuthorityCount, SigningCommitment<C::Point>>,
    responses: &BTreeMap<AuthorityCount, SigningResponse<C::Point>>,
) -> Result<C::Signature, BTreeSet<AuthorityCount>> {
    let bindings = generate_bindings(msg_hash, commitments, signer_idxs);

    let group_commitment = gen_group_commitment(commitments, &bindings);

    let challenge = C::build_challenge(agg_pubkey, group_commitment, msg_hash);

    let invalid_idxs: BTreeSet<AuthorityCount> = signer_idxs
        .iter()
        .copied()
        .filter(|signer_idx| {
            let rho_i = bindings[signer_idx].clone();
            let lambda_i = get_lagrange_coeff::<C::Point>(*signer_idx, signer_idxs).unwrap();

            let commitment = &commitments[signer_idx];
            let commitment_i = commitment.d + (commitment.e * rho_i);

            let y_i = pubkeys[signer_idx];

            let response = &responses[signer_idx];

            !is_party_response_valid(
                &y_i,
                &lambda_i,
                &commitment_i,
                &challenge,
                &response.response,
            )
        })
        .collect();

    if invalid_idxs.is_empty() {
        // Response shares/shards are additive, so we simply need to
        // add them together (see step 7.c in Figure 3, page 15).
        let z: <C::Point as ECPoint>::Scalar = responses
            .iter()
            .map(|(_idx, sig)| sig.response.clone())
            .sum();

        Ok(C::build_signature(z, group_commitment))
    } else {
        Err(invalid_idxs)
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    use crate::multisig::{
        client::tests::{gen_invalid_local_sig, gen_invalid_signing_comm1},
        crypto::eth::{EthSigning, Point, Scalar},
    };

    use rand_legacy::SeedableRng;

    const SECRET_KEY: &str = "fbcb47bc85b881e0dfb31c872d4e06848f80530ccbd18fc016a27c4a744d0eba";
    const NONCE_KEY: &str = "d51e13c68bf56155a83e50fd9bc840e2a1847fb9b49cd206a577ecd1cd15e285";
    const MESSAGE_HASH: &str = "2bdc19071c7994f088103dbf8d5476d6deb6d55ee005a2f510dc7640055cc84e";

    // Through integration tests with the KeyManager contract we know this
    // to be deemed valid by the contract for the data above
    const EXPECTED_SIGMA: &str = "beb37e87509e15cd88b19fa224441c56acc0e143cb25b9fd1e57fdafed215538";

    #[test]
    fn signature_is_contract_compatible() {
        // Given the signing key, nonce and message hash, check that
        // sigma (signature response) is correct and matches the expected
        // (by the KeyManager contract) value
        let msg_hash: [u8; 32] = hex::decode(MESSAGE_HASH)
            .unwrap()
            .try_into()
            .expect("invalid hash size");

        let nonce = Scalar::from_hex(NONCE_KEY);
        let commitment = Point::from_scalar(&nonce);

        let private_key = Scalar::from_hex(SECRET_KEY);
        let public_key = Point::from_scalar(&private_key);

        let response = generate_schnorr_response::<EthSigning>(
            &private_key,
            public_key,
            commitment,
            nonce,
            &msg_hash,
        );

        assert_eq!(hex::encode(response.as_bytes()), EXPECTED_SIGMA);

        // Build the challenge again to match how it is done on the receiving side
        let challenge = EthSigning::build_challenge(public_key, commitment, &msg_hash);

        // A lambda that has no effect on the computation (as a way to adapt multi-party
        // signing to work for a single party)
        let dummy_lambda = Scalar::from_usize(1);

        assert!(is_party_response_valid(
            &public_key,
            &dummy_lambda,
            &commitment,
            &challenge,
            &response,
        ));
    }

    #[test]
    fn check_data_size_stage2() {
        let mut rng = Rng::from_seed([0; 32]);
        let test_size = 4;
        let data_to_check =
            SigningData::<Point>::BroadcastVerificationStage2(BroadcastVerificationMessage {
                data: (0..test_size)
                    .map(|i| {
                        (
                            i as AuthorityCount,
                            Some(gen_invalid_signing_comm1(&mut rng)),
                        )
                    })
                    .collect(),
            });

        // Should fail on sizes larger or smaller then expected
        assert!(data_to_check.check_data_size(Some(test_size)));
        assert!(!data_to_check.check_data_size(Some(test_size - 1)));
        assert!(!data_to_check.check_data_size(Some(test_size + 1)));
    }

    #[test]
    fn check_data_size_stage4() {
        let mut rng = Rng::from_seed([0; 32]);
        let test_size = 4;
        let data_to_check =
            SigningData::<Point>::VerifyLocalSigsStage4(BroadcastVerificationMessage {
                data: (0..test_size)
                    .map(|i| (i as AuthorityCount, Some(gen_invalid_local_sig(&mut rng))))
                    .collect(),
            });

        // Should fail on sizes larger or smaller then expected
        assert!(data_to_check.check_data_size(Some(test_size)));
        assert!(!data_to_check.check_data_size(Some(test_size - 1)));
        assert!(!data_to_check.check_data_size(Some(test_size + 1)));
    }

    #[test]
    #[should_panic]
    fn check_data_size_should_panic_with_none_on_non_initial_stage() {
        let data_to_check =
            SigningData::<Point>::BroadcastVerificationStage2(BroadcastVerificationMessage {
                data: BTreeMap::new(),
            });

        data_to_check.check_data_size(None);
    }
}
