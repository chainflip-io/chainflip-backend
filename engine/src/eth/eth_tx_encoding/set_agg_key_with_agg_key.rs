use std::{collections::HashMap, convert::TryInto};

use crate::{
    eth::key_manager::KeyManager,
    mq::{pin_message_stream, IMQClient, Subject},
    p2p::ValidatorId,
    settings,
    signing::{
        crypto::Signature, KeyId, KeygenOutcome, KeygenSuccess, MessageHash, MessageInfo,
        MultisigEvent, MultisigInstruction, SigningInfo,
    },
    types::chain::Chain,
};

use anyhow::Result;
use futures::StreamExt;
use serde::{Deserialize, Serialize};
use sp_core::Hasher;
use sp_runtime::traits::Keccak256;
use std::str::FromStr;
use web3::{ethabi::Token, types::Address};

use curv::{
    arithmetic::Converter,
    elliptic::curves::{secp256_k1::Secp256k1Point, traits::ECPoint},
};
use secp256k1::{PublicKey, Secp256k1, SecretKey};

/// Helper function, constructs and runs the [SetAggKeyWithAggKeyEncoder] asynchronously.
pub async fn start<M: IMQClient + Clone>(
    settings: &settings::Settings,
    mq_client: M,
) -> Result<()> {
    let mut encoder = SetAggKeyWithAggKeyEncoder::new(
        settings.eth.key_manager_eth_address.as_ref(),
        settings.signing.genesis_validator_ids.clone(),
        mq_client,
    )?;

    encoder.process_multi_sig_event_stream().await;

    Ok(())
}

/// Details of a transaction to be broadcast to ethereum.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub(super) struct TxDetails {
    pub contract_address: Address,
    pub data: Vec<u8>,
}

// TODO: Use signing::MessageHash once it's updated to use [u8; 32]
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq, Hash, Eq)]
pub struct FakeMessageHash(pub [u8; 32]);

/// Reads [AuctionConfirmedEvent]s off the message queue and encodes the function call to the stake manager.
#[derive(Clone)]
struct SetAggKeyWithAggKeyEncoder<M: IMQClient> {
    mq_client: M,
    key_manager: KeyManager,
    // maps the MessageHash which gets sent to the signer with the data that the MessageHash is a hash of
    messages: HashMap<FakeMessageHash, ParamContainer>,
    // On genesis, where do these validators come from, to allow for the first key update
    validators: HashMap<KeyId, Vec<ValidatorId>>,
    curr_signing_key_id: Option<KeyId>,
    next_key_id: Option<KeyId>,
}

#[derive(Clone)]
struct ParamContainer {
    pub key_id: KeyId,
    pub key_nonce: [u8; 32],
    pub pubkey_x: [u8; 32],
    pub pubkey_y_parity: u8,
}

impl<M: IMQClient + Clone> SetAggKeyWithAggKeyEncoder<M> {
    fn new(
        key_manager_address: &str,
        genesis_validator_ids: Vec<ValidatorId>,
        mq_client: M,
    ) -> Result<Self> {
        let key_manager = KeyManager::load(key_manager_address)?;

        let mut genesis_validator_ids_hash_map = HashMap::new();
        genesis_validator_ids_hash_map
            .entry(KeyId(0))
            .or_insert(genesis_validator_ids);
        Ok(Self {
            mq_client,
            key_manager,
            messages: HashMap::new(),
            validators: genesis_validator_ids_hash_map,
            curr_signing_key_id: Some(KeyId(0)),
            next_key_id: None,
        })
    }

    /// Read events from the MultisigEvent subject and process them
    /// The messages we care about are:
    /// 1. `MultisigEvent::KeygenResult` which is emitted after a new key has been
    /// successfully generated by the signing module
    /// 2. `MultisigEvent::MessagedSigned` which is emitted after the Signing module
    /// has successfully signed a message with a particular (denoted by KeyId) key
    async fn process_multi_sig_event_stream(&mut self) {
        let multisig_event_stream = self
            .mq_client
            .subscribe::<MultisigEvent>(Subject::MultisigEvent)
            .await
            .unwrap();

        let mut multisig_event_stream = pin_message_stream(multisig_event_stream);

        while let Some(event) = multisig_event_stream.next().await {
            match event {
                Ok(event) => {
                    match event {
                        MultisigEvent::KeygenResult(key_outcome) => {
                            match key_outcome {
                                KeygenOutcome::Success(keygen_success) => {
                                    self.handle_keygen_success(keygen_success).await;
                                }
                                // TODO: Be more granular with log messages here
                                _ => {
                                    log::error!("Signing module returned error generating key")
                                }
                            }
                        }
                        MultisigEvent::MessageSigned(msg, sig) => {
                            self.handle_set_agg_key_message_signed(msg, sig).await;
                        }
                        _ => {
                            log::trace!("Discarding non keygen result or message signed event")
                        }
                    }
                }
                Err(e) => {
                    log::error!("Error reading event from multisig event stream");
                }
            }
        }
    }

    // When the keygen message has been received we must:
    // 1. Build the ETH encoded setAggKeyWithAggKey transaction parameters
    // 2. Store the tx parameters in state for use later
    // 3. Create a Signing Instruction
    // 4. Push this instruction to the MQ for the signing module to pick up
    async fn handle_keygen_success(&mut self, keygen_success: KeygenSuccess) {
        // process the keygensuccess

        // Question: Why do we have to encode the params in the eth format. We could just serialize the params from a struct
        // and then sign that. This would make it much clearer than going back and forth between ETH encoding.
        let (encoded_fn_params, param_container) = self
            .build_encoded_fn_params(&keygen_success)
            .expect("should be a valid encoded params");

        let hash = Keccak256::hash(&encoded_fn_params[..]);
        let message_hash = FakeMessageHash(hash.into());

        // store key: parameters, so we can fetch the parameters again, after the payload
        // has been signed by the signing module
        self.messages.insert(message_hash.clone(), param_container);

        // Use *all* the validators for now
        let key_id = self.curr_signing_key_id.expect("KeyId should be set here");
        let signing_info = SigningInfo::new(
            key_id,
            self.validators
                .get(&key_id)
                .expect("validators should exist for current KeyId")
                .clone(),
        );

        let message_hash = MessageHash(message_hash.0.to_vec());
        let signing_instruction = MultisigInstruction::Sign(message_hash, signing_info);

        self.mq_client
            .publish(Subject::MultisigInstruction, &signing_instruction)
            .await
            .expect("Should publish to MQ");
    }

    // TODO: Clean up
    fn point_to_pubkey(&self, point: Secp256k1Point) -> PublicKey {
        let bytes: [u8; 32] = point
            .x_coor()
            .expect("should be a valid point")
            .to_bytes()
            .try_into()
            .expect("Should be a valid point");

        PublicKey::from_slice(&bytes).expect("Should be valid pubkey")
    }

    // When the signed message has been received we must:
    // 1. Get the parameters (`ParameterContainer`) that we stored in state (and submitted to the signing module in encoded form) earlier
    // 2. Build a valid ethereum encoded transaction using the message hash and signature returned by the Signing module
    // 3. Push this transaction to the Broadcast(Chain::ETH) subject, to be broadcast by the ETH Broadcaster
    // 4. Update the current key id, with the new key id returned by the signing module, so we know which key to sign with
    // from now onwards, until the next successful key rotation
    async fn handle_set_agg_key_message_signed(&mut self, msg: MessageInfo, sig: Signature) {
        // 1. Get the data from the message hash that was signed (using the `messages` field)
        let k_g = self.point_to_pubkey(sig.v);
        let nonce_times_g_addr = self.nonce_times_g_addr_from_v(k_g);

        let key_id = msg.key_id;
        let msg: FakeMessageHash = FakeMessageHash(msg.hash.0.try_into().unwrap());
        let params = self
            .messages
            .get(&msg)
            .expect("should have been stored when asked to sign");
        // 2. Call build_tx with the required info
        match self.build_tx(&msg, &sig, nonce_times_g_addr, params) {
            Ok(ref tx_details) => {
                // 3. Send it on its way to the eth broadcaster
                self.mq_client
                    .publish(Subject::Broadcast(Chain::ETH), tx_details)
                    .await
                    .unwrap_or_else(|err| {
                        log::error!("Could not process: {:#?}", err);
                    });
                // here we assume the key was update successfully
                // update curr key id
                self.curr_signing_key_id = Some(key_id);
                // reset
                self.next_key_id = None;
            }
            Err(err) => {
                log::error!("Failed to build: {:#?}", err);
            }
        }
    }

    fn build_tx(
        &self,
        msg: &FakeMessageHash,
        sig: &Signature,
        nonce_times_g_addr: [u8; 20],
        params: &ParamContainer,
    ) -> Result<TxDetails> {
        let sig_scalar =
            serde_json::to_string(&sig.sigma).expect("Failed to serialize the sig scalar");
        let sig_scalar: [u8; 32] = sig_scalar.as_bytes().try_into().unwrap();

        let params = [
            // SigData
            Token::Tuple(vec![
                Token::Uint(msg.0.into()),                 // msgHash
                Token::Uint(params.key_nonce.into()),      // key nonce
                Token::Uint(sig_scalar.into()),            // sig - this is 's' in the literature
                Token::Address(nonce_times_g_addr.into()), // nonceTimesGAddr
            ]),
            // Key
            Token::Tuple(vec![
                Token::Uint(params.pubkey_x.into()),        // pubkeyX
                Token::Uint(params.pubkey_y_parity.into()), // pubkeyYparity
            ]),
        ];

        let tx_data = self
            .key_manager
            .set_agg_key_with_agg_key()
            .encode_input(&params[..])?;

        Ok(TxDetails {
            contract_address: self.key_manager.deployed_address,
            data: tx_data.into(),
        })
    }

    /// v is 'r' in the literature. r = k * G where k is the nonce and G is the address generator
    fn nonce_times_g_addr_from_v(&self, v: secp256k1::PublicKey) -> [u8; 20] {
        let s = Secp256k1::signing_only();

        let v_pub: [u8; 64] = v.serialize_uncompressed()[1..]
            .try_into()
            .expect("Should be a valid pubkey");

        // calculate nonce times g addr - the hash over
        let nonce_times_g_addr_hash = Keccak256::hash(&v_pub).as_bytes().to_owned();

        // take the last 160bits (20 bytes)
        let nonce_times_g_addr: [u8; 20] = nonce_times_g_addr_hash[140..]
            .try_into()
            .expect("should only be 20 bytes long");

        return nonce_times_g_addr;
    }

    // This has nothing to do with building an ETH transaction.
    // We encode the tx like this, in eth format, because this is how the contract will
    // serialise the data to verify the signature over the message hash
    fn build_encoded_fn_params(
        &self,
        keygen_success: &KeygenSuccess,
    ) -> Result<(Vec<u8>, ParamContainer)> {
        let pubkey = keygen_success.key;

        let pubkey_bytes: [u8; 33] = pubkey.serialize();
        let pubkey_y_parity_byte = pubkey_bytes[0];
        let pubkey_y_parity = if pubkey_y_parity_byte == 2 { 0u8 } else { 1u8 };
        let pubkey_x: [u8; 32] = pubkey_bytes[1..].try_into().expect("Is valid pubkey");

        let param_container = ParamContainer {
            key_id: keygen_success.key_id,
            pubkey_x,
            pubkey_y_parity,
            key_nonce: [0u8; 32],
        };

        // key nonce???? we should have a nonce for the key here... is it derived or related to key id in anyway?
        // why do we have key nonce and key id?
        let params = self.set_agg_key_with_agg_key_param_constructor(
            [0u8; 32],
            3u64,
            [0u8; 32],
            [0u8; 20],
            pubkey_x,
            pubkey_y_parity,
        );

        // Serialize the data using eth encoding so the KeyManager contract can serialize the data in the same way
        // in order to verify the signature
        let tx_data = self
            .key_manager
            .set_agg_key_with_agg_key()
            .encode_input(&params[..])?;

        return Ok((tx_data, param_container));
    }

    // not sure if key nonce should be u64...
    // sig = s in the literature. The scalar of the signature
    fn set_agg_key_with_agg_key_param_constructor(
        &self,
        msg_hash: [u8; 32],
        key_nonce: u64,
        sig: [u8; 32],
        nonce_times_g_addr: [u8; 20],
        pubkey_x: [u8; 32],
        pubkey_y_parity: u8,
    ) -> [Token; 2] {
        [
            // SigData
            Token::Tuple(vec![
                Token::Uint(msg_hash.into()),              // msgHash
                Token::Uint(key_nonce.into()),             // key nonce
                Token::Uint(sig.into()), // sig - this 's' in the literature, the signature scalar
                Token::Address(nonce_times_g_addr.into()), // nonceTimesGAddr - this is r in the literature
            ]),
            // Key - the signing module will sign over the params, containing this
            Token::Tuple(vec![
                Token::Uint(pubkey_x.into()),        // pubkeyX
                Token::Uint(pubkey_y_parity.into()), // pubkeyYparity
            ]),
        ]
    }
}

#[cfg(test)]
mod test_eth_tx_encoder {
    use super::*;
    use curv::arithmetic::Converter;
    use hex;

    use crate::mq::mq_mock::MQMock;

    #[test]
    fn test_point_to_pubkey() {
        // let fake_address = hex::encode([12u8; 20]);
        // let settings = settings::test_utils::new_test_settings().unwrap();

        // let mq = MQMock::new();
        // let mq_c = mq.get_client();

        // let encoder = SetAggKeyWithAggKeyEncoder::new(
        //     &fake_address[..],
        //     settings.signing.genesis_validator_ids,
        //     mq_c,
        // )
        // .unwrap();

        // Serialized point: "{\"x\":\"8d13221e3a7326a34dd45214ba80116dd142e4b5ff3ce66a8dc7bfa0378b795\",\"y\":\"5d41ac1477614b5c0848d50dbd565ea2807bcba1df0df07a8217e9f7f7c2be88\"}"
        const BASE_POINT2_X: [u8; 32] = [
            0x08, 0xd1, 0x32, 0x21, 0xe3, 0xa7, 0x32, 0x6a, 0x34, 0xdd, 0x45, 0x21, 0x4b, 0xa8,
            0x01, 0x16, 0xdd, 0x14, 0x2e, 0x4b, 0x5f, 0xf3, 0xce, 0x66, 0xa8, 0xdc, 0x7b, 0xfa,
            0x03, 0x78, 0xb7, 0x95,
        ];
        const BASE_POINT2_Y: [u8; 32] = [
            0x5d, 0x41, 0xac, 0x14, 0x77, 0x61, 0x4b, 0x5c, 0x08, 0x48, 0xd5, 0x0d, 0xbd, 0x56,
            0x5e, 0xa2, 0x80, 0x7b, 0xcb, 0xa1, 0xdf, 0x0d, 0xf0, 0x7a, 0x82, 0x17, 0xe9, 0xf7,
            0xf7, 0xc2, 0xbe, 0x88,
        ];

        let x_direct_hex = hex::encode(&BASE_POINT2_X);
        println!("x direct hex: {:?}", x_direct_hex);

        let big_int_x = curv::BigInt::from_bytes(&BASE_POINT2_X);
        let big_int_y = curv::BigInt::from_bytes(&BASE_POINT2_Y);
        let point: Secp256k1Point = Secp256k1Point::from_coor(&big_int_x, &big_int_y);

        println!("x coor: {:?}", point.x_coor());
        // Must go to bytes and then hex::encode, bigint.hex() tends to drop a character which is very annoying
        let x_point = point.x_coor().unwrap().to_bytes();
        let x_point_hex = hex::encode(x_point);
        println!("xpoint hex {:#?}, len: {}", x_point_hex, x_point_hex.len());

        // let bytes = hex::decode(x_point.clone()).unwrap();
        // prepend 0x04 to represent the uncompressed key

        // println!("bytes: {:#?}", bytes);
    }

    // #[ignore = "Not fully implemented"]
    // #[test]
    // fn test_tx_build() {
    //     let fake_address = hex::encode([12u8; 20]);
    //     let settings = settings::test_utils::new_test_settings().unwrap();
    //     let mq = MQMock::new();

    //     let encoder = SetAggKeyWithAggKeyEncoder::new(
    //         &fake_address[..],
    //         settings.signing.genesis_validator_ids,
    //         mq.get_client(),
    //     )
    //     .expect("Unable to intialise encoder");

    //     let event = FakeNewAggKeySigningComplete {
    //         hash: FakeMessageHash([0; 32]),
    //         sig: [0; 32],
    //     };

    //     let param_container = ParamContainer {
    //         key_id: KeyId(1),
    //         nonce: 3u64,
    //         pubkey_x: [0; 32],
    //         pubkey_y_parity: [0; 32],
    //         nonce_times_g_addr: [0; 20],
    //     };

    //     let _ = encoder
    //         .build_tx(&event, &param_container)
    //         .expect("Unable to encode tx details");
    // }

    #[test]
    fn secp256k1_sanity_check() {
        let s = secp256k1::Secp256k1::signing_only();

        let sk = secp256k1::SecretKey::from_str(
            "01010101010101010001020304050607ffff0000ffff00006363636363636363",
        )
        .unwrap();

        let pubkey_from_sk = PublicKey::from_secret_key(&s, &sk);

        // these keys should be derivable from each other.
        let pubkey = secp256k1::PublicKey::from_str(
            "0218845781f631c48f1c9709e23092067d06837f30aa0cd0544ac887fe91ddd166",
        )
        .unwrap();

        // for sanity
        assert_eq!(pubkey_from_sk, pubkey);
    }

    // #[test]
    // fn test_crypto_parts() {
    //     let fake_address = hex::encode([12u8; 20]);
    //     let settings = settings::test_utils::new_test_settings().unwrap();

    //     let mq = MQMock::new();
    //     let mq_c = mq.get_client();

    //     let encoder = SetAggKeyWithAggKeyEncoder::new(
    //         &fake_address[..],
    //         settings.signing.genesis_validator_ids,
    //         mq_c,
    //     )
    //     .unwrap();

    //     let pubkey = secp256k1::PublicKey::from_str(
    //         "0218845781f631c48f1c9709e23092067d06837f30aa0cd0544ac887fe91ddd166",
    //     )
    //     .unwrap();

    //     let nonce: [u8; 32] =
    //         hex::decode("d51e13c68bf56155a83e50fd9bc840e2a1847fb9b49cd206a577ecd1cd15e285")
    //             .unwrap()
    //             .try_into()
    //             .unwrap();

    //     let () = encoder.generate_crypto_parts(pubkey, nonce);
    // }

    // #[test]
    // fn test_build_encodings() {
    //     let fake_address = hex::encode([12u8; 20]);
    //     let settings = settings::test_utils::new_test_settings().unwrap();
    //     let mq = MQMock::new();

    //     let encoder = SetAggKeyWithAggKeyEncoder::new(
    //         &fake_address[..],
    //         settings.signing.genesis_validator_ids,
    //         mq.get_client(),
    //     )
    //     .expect("Unable to intialise encoder");

    //     let event = FakeNewAggKey {
    //         pubkey_x: [0; 32],
    //         pubkey_y_parity: [0; 32],
    //         nonce_times_g_addr: [0; 20],
    //     };

    //     let _ = encoder
    //         .build_encoded_fn_params(&event)
    //         .expect("Unable to encode tx details");
    // }
}
